# Get the directory where this script resides
set thisDir 	        [file dirname [info script]]
set workDir 	        [file join $thisDir {{ project_location_join_syntax }}]
set kuugaDir            [file join $thisDir {{ kuuga_location_join_syntax }}]
set godaiDir	        [file join $kuugaDir Godai]
set gouramDir 	        [file join $kuugaDir Gouram]
set core2AXIDir	        [file join $kuugaDir core2axi]
set instContents        [file join $thisDir .. mem {{ instruction_memory_file }}]
set dataContents        [file join $thisDir .. mem {{ data_memory_file }}]
set finalBitfile        [file join $thisDir .. output {{ benchmark }}.bit]

set projectName {{ project_name }}

# Check whether the project exists or not, if it doesn't then it needs to be created

if {![file exist [file join $workDir {{ project_name }}.xpr ]] || {{ resynth }}} {

    source [file join $godaiDir scripts godai_manifest.tcl]
    source [file join $gouramDir scripts gouram_manifest.tcl]
    source [file join $core2AXIDir scripts core2axi_manifest.tcl]
    source [file join $kuugaDir scripts kuuga_manifest.tcl]

    set RTLFileListNames [concat [list $core2AXIRTLFiles $core2AXIDir] [list $GodaiRTLFiles $godaiDir] [list $GouramRTLFiles $gouramDir] [list $KuugaRTLFiles $kuugaDir]]
    set IncludeFileListNames [concat [list $GodaiIncludeFiles $godaiDir] [list $GouramIncludeFiles $gouramDir] [list $KuugaIncludeFiles $kuugaDir]]

    set rtlFilesFull {}
    set includeFilesFull {}

    foreach {ls dir} $RTLFileListNames {
        foreach f $ls {
            lappend rtlFilesFull [file join $dir rtl $f]
        }
    }

    foreach {ls dir} $IncludeFileListNames {
        foreach f $ls {
            lappend includeFilesFull [file join $dir include $f]
        }
    }

    # Create project
    create_project -part xc7vx485tffg1761-2  -force $projectName [file join $workDir]

    {% for top_level in top_levels %}
    add_files -fileset sources_1 [file join $thisDir {{ top_level[0] }}]
    {% endfor %}
    add_files -fileset sources_1 $instContents
    add_files -fileset sources_1 $dataContents
    add_files -norecurse $rtlFilesFull
    add_files -norecurse $includeFilesFull

    # Set the directory path for the new project
    set proj_dir [get_property directory [current_project]]

    # Set project properties
    set obj [get_projects $projectName]
    set_property "board_part" "xilinx.com:vc707:part0:1.0" $obj
    set_property "simulator_language" "Mixed" $obj
    set_property "target_language" "Verilog" $obj

    {% for top_level in top_levels %}
    source [file join $kuugaDir scripts block_diagrams {{ top_level[2] }}.tcl]
    {% endfor %}

} else {
    open_project [file join $workDir {{ project_name }}.xpr]
}

# If we need to re-synthesise and re-implement then do both of those so we have access to the bitfile

{# Need to add in ability to pick a new top level and re-sythesise #}

set toplevelDesigns { {%- for top_level in top_levels  %} {{ top_level[1] }} {% endfor %} }

set toplevelList [join [list [lrange $toplevelDesigns 0 [expr [lsearch $toplevelDesigns [get_property top [current_fileset]]] -1]] [get_property top [current_fileset]] [lrange $toplevelDesigns [expr [lsearch $toplevelDesigns [get_property top [current_fileset]]] + 1] end]]]

foreach {toplevel} $toplevelList {

    if { [get_property top [current_fileset]] != $toplevel } {
        set_property top $top_level [current_fileset]
    }

    if { [get_property NEEDS_REFRESH [get_runs impl_1]] || [get_property STATUS [get_runs synth_1]] == "Not started" } {
        reset_run synth_1
        reset_run impl_1
        launch_runs -jobs 4 synth_1
        wait_on_run synth_1
        launch_runs -jobs 4 impl_1
        wait_on_run impl_1
    }

    # Create the baseline bit file & probes file and write them out to a known location
    set raw_bit_file [file join $thisDir {{ benchmark }}_raw.bit]
    set raw_probes_file [file join $thisDir {{ benchmark }}_debug_probes.ltx]
    set raw_mmi [file join $thisDir layout.mmi]
    open_run impl_1
    write_bitstream -force $raw_bit_file
    write_debug_probes -force $raw_probes_file
    write_mem_info -force $raw_mmi

    # Program the Device & Extract the Triggers to a file
    open_hw
    disconnect_hw_server -quiet
    connect_hw_server -url localhost:12345
    current_hw_target [get_hw_targets */xilinx_tcf/Digilent/000000007071A]
    set_property PARAM.FREQUENCY 3750000 [get_hw_targets */xilinx_tcf/Digilent/000000007071A]
    open_hw_target
    set_property PROBES.FILE $raw_probes_file [get_hw_devices xc7vx485t_0]
    set_property FULL_PROBES.FILE $raw_probes_file [get_hw_devices xc7vx485t_0]
    set_property PROGRAM.FILE $raw_bit_file [get_hw_devices xc7vx485t_0]
    program_hw_devices [get_hw_devices xc7vx485t_0]
    refresh_hw_device [lindex [get_hw_devices xc7vx485t_0] 0]
    set ilaTriggers [file join $thisDir ila_triggers.tas]
    run_hw_ila -force -file $ilaTriggers [get_hw_ilas hw_ila_1]

    # Add triggers into the design
    current_design impl_1
    refresh_design
    set_property TRIGGER_COMPARE_VALUE eq1'b1 [get_hw_probes k_top/system_ila_0/inst/probe8_1 -of_objects [get_hw_ilas -of_objects [get_hw_devices xc7vx485t_0] -filter {CELL_NAME=~"k_top/system_ila_0/inst/ila_lib"}]]
    apply_hw_ila_trigger $ilaTriggers
    set triggersBitfile [file join $thisDir {{ benchmark }}_with_triggers.bit]
    write_bitstream -force $triggersBitfile

    # Run updatemem with mem files from params
    exec updatemem -debug -force -meminfo $raw_mmi -bit $triggersBitfile \
        -proc xpm_inst_mem/xpm_memory_base_inst -data $instContents \
        -proc xpm_data_mem/xpm_memory_base_inst -data $dataContents \
        -out $finalBitfile

    break;

}


