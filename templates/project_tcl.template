# Get the directory where this script resides
set thisDir 	        [file dirname [info script]]
set workDir 	        [file join $thisDir {{ project_location_join_syntax }}]
set kuugaDir            [file join $thisDir {{ kuuga_location_join_syntax }}]
set godaiDir	        [file join $kuugaDir Godai]
set gouramDir 	        [file join $kuugaDir Gouram]
set core2AXIDir	        [file join $kuugaDir core2axi]
set instContents        [file join $thisDir .. mem {{ instruction_memory_file }}]
set dataContents        [file join $thisDir .. mem {{ data_memory_file }}]
set finalBitfile        [file join $thisDir .. output {{ benchmark }}.bit]

set projectName {{ project_name }}

# Check whether the project exists or not, if it doesn't then it needs to be created

if {![file exist [file join $workDir {{ project_name }}.xpr ]] || {{ resynth }}} {

    source [file join $godaiDir scripts godai_manifest.tcl]
    source [file join $gouramDir scripts gouram_manifest.tcl]
    source [file join $core2AXIDir scripts core2axi_manifest.tcl]

    set RTLFileListNames [concat [list $core2AXIRTLFiles $core2AXIDir] [list $GodaiRTLFiles $godaiDir] [list $GouramRTLFiles $gouramDir]]
    set IncludeFileListNames [concat [list $GodaiIncludeFiles $godaiDir] [list $GouramIncludeFiles $gouramDir]]

    set rtlFilesFull {}
    set includeFilesFull {}

    foreach {ls dir} $RTLFileListNames {
        foreach f $ls {
            lappend rtlFilesFull [file join $dir rtl $f]
        }
    }

    foreach {ls dir} $IncludeFileListNames {
        foreach f $ls {
            lappend includeFilesFull [file join $dir include $f]
        }
    }

    # Create project
    create_project -part xc7vx485tffg1761-2  -force $projectName [file join $workDir]

    add_files -fileset sources_1 [file join $thisDir {{ top_level_file }}]
    add_files -fileset sources_1 $instContents
    add_files -fileset sources_1 $dataContents
    add_files -norecurse $rtlFilesFull
    add_files -norecurse $includeFilesFull
    set_property top {{ top_level_module }} [get_filesets sources_1]

    # Set the directory path for the new project
    set proj_dir [get_property directory [current_project]]

    # Set project properties
    set obj [get_projects $projectName]
    set_property "board_part" "xilinx.com:vc707:part0:1.0" $obj
    set_property "simulator_language" "Mixed" $obj
    set_property "target_language" "Verilog" $obj

    source [file join $kuugaDir scripts block_diagrams kuuga_full_system.tcl]

} else {
    open_project [file join $workDir {{ project_name }}.xpr]
}

# If we need to re-synthesise and re-implement then do both of those so we have access to the bitfile

if { [get_property NEEDS_REFRESH [get_runs impl_1]] || [get_property STATUS [get_runs synth_1]] == "Not started" } {
    launch_runs -jobs 4 synth_1
    wait_on_run synth_1
    launch_runs -jobs 4 impl_1
    wait_on_run impl_1
}

# Create the baseline bit file & probes file and write them out to a known location
set raw_bit_file [file join $thisDir {{ benchmark }}_raw.bit]
set raw_probes_file [file join $thisDir {{ benchmark }}_debug_probes.ltx]
set raw_mmi [file join $thisDir layout.mmi]
open_run impl_1
write_bitstream -force $raw_bit_file
#write_debug_probes -force $raw_probes_file
write_mem_info -force $raw_mmi

# Program the Device & Extract the Triggers to a file
#open_hw
#disconnect_hw_server -quiet
#connect_hw_server -url localhost:12345
#current_hw_target [get_hw_targets */xilinx_tcf/Digilent/000000007071A]
#set_property PARAM.FREQUENCY 3750000 [get_hw_targets */xilinx_tcf/Digilent/000000007071A]
#open_hw_target
#set_property PROBES.FILE $raw_probes_file [get_hw_devices xc7vx485t_0]
#set_property FULL_PROBES.FILE $raw_probes_file [get_hw_devices xc7vx485t_0]
#set_property PROGRAM.FILE $raw_bit_file [get_hw_devices xc7vx485t_0]
#program_hw_devices [get_hw_devices xc7vx485t_0]
#refresh_hw_device [lindex [get_hw_devices xc7vx485t_0] 0]
#set ilaTriggers [file join $thisDir ila_triggers.tas]
#run_hw_ila -force -file $ilaTriggers [get_hw_ilas hw_ila_1]

# Add triggers into the design
#current_design impl_1
#refresh_design
#apply_hw_ila_trigger $ilaTriggers
#set triggersBitfile [file join $thisDir {{ benchmark }}_with_triggers.bit]
#write_bitstream -force $triggersBitfile

# Run updatemem with mem files from params
exec updatemem -debug -force -meminfo $raw_mmi -bit $raw_bit_file \
    -proc xpm_inst_mem/xpm_memory_base_inst -data $instContents \
    -proc xpm_data_mem/xpm_memory_base_inst -data $dataContents \
    -out $finalBitfile


